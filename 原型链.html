<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<!--
			1.原型链
			*先在自身属性查找,找到返回
			*如果没有, 再沿着__proto__这条链向上查找,找到返回
			* 如果最终没有找到,返回undefined
			
			
			
			
			
		-->
		<img src="img/yuanxinglian.jpg"/>
	</body>
	<script type="text/javascript">
		// 解释https://blog.csdn.net/miaohuizijidegushi/article/details/81004355
		//其实这是一个有点小意思的现象，因为当你在Chrome Console点击展开数组时，会重新去读一遍内存真实的值然后显示，一但展开后就不会再变。
		var a = 0;
		var b = a;
		console.log(b)//0
		a = 1;
		var obj = {name:'A'};
		var obj1 = obj;
		console.log(obj1)
		console.log(obj1.name)
		obj.name = "B";
		console.log(obj1)
		console.log(obj1.name)
		console.log('-------------------------------------------------')
		function Fn (){
			this.test1 = function (){
				console.log('t1')
			}
		}
		Fn.prototype.test2 = function (){
			console.log('t2')
		}
		
		
		var fn = new Fn();
		fn.test1();
		fn.test2();
		console.log(fn.toString());
//		fn.test();
		/*
		 
		 * 函数的显示原型指向对象:默认是空的Object实例对象,(但Object不满足)
		 * 所有函数都是Function的实例(Function是它自身的实例)
		 * Object的原型对象是原型链的尽头
		 * 
		 * */
		console.log(Object.prototype instanceof Object)//true
		console.log(Function.prototype === Function.__proto__)//true,所有函数都是Function的实例(Function是它自身的实例)
	</script>
</html>
